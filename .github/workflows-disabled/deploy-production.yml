name: üöÄ Production Deployment

on:
  push:
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        default: false
        type: boolean
      rollback:
        description: 'Rollback to previous version'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}
  KUSTOMIZE_VERSION: '5.0.0'
  KUBECTL_VERSION: '1.28.0'

jobs:
  # =============================================================================
  # PRE-DEPLOYMENT VALIDATION
  # =============================================================================
  pre-deployment-checks:
    name: ‚úÖ Pre-deployment Validation
    runs-on: ubuntu-latest
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy-url.outputs.url }}

    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      namespace: ${{ steps.set-env.outputs.namespace }}
      domain: ${{ steps.set-env.outputs.domain }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment variables
      id: set-env
      run: |
        ENV="${{ github.event.inputs.environment || 'production' }}"
        echo "environment=${ENV}" >> $GITHUB_OUTPUT
        
        if [ "${ENV}" = "production" ]; then
          echo "namespace=legal-ai-system" >> $GITHUB_OUTPUT
          echo "domain=legal-ai.example.com" >> $GITHUB_OUTPUT
        else
          echo "namespace=legal-ai-${ENV}" >> $GITHUB_OUTPUT
          echo "domain=legal-ai-${ENV}.example.com" >> $GITHUB_OUTPUT
        fi

    - name: Validate deployment tag/branch
      if: github.event.inputs.rollback != 'true'
      run: |
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "‚úÖ Deploying from tag: ${{ github.ref_name }}"
        elif [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
          echo "‚ö†Ô∏è Force deployment from branch: ${{ github.ref_name }}"
        else
          echo "‚ùå Production deployments require a version tag or force flag"
          exit 1
        fi

    - name: Check deployment approval
      if: steps.set-env.outputs.environment == 'production'
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ secrets.GITHUB_TOKEN }}
        approvers: ${{ vars.PRODUCTION_APPROVERS }}
        minimum-approvals: 2
        issue-title: "Production Deployment Approval - ${{ github.ref_name }}"
        issue-body: |
          ## Production Deployment Request
          
          **Version**: ${{ github.ref_name }}
          **Commit**: ${{ github.sha }}
          **Author**: ${{ github.actor }}
          
          ### Changes
          ${{ github.event.head_commit.message }}
          
          ### Pre-deployment Checklist
          - [ ] All tests passing
          - [ ] Security scans completed
          - [ ] Database migrations tested
          - [ ] Rollback plan verified
          - [ ] Monitoring alerts configured
          
          Please review and approve this deployment.

  # =============================================================================
  # DATABASE MIGRATION AND BACKUP
  # =============================================================================
  database-migration:
    name: üóÉÔ∏è Database Migration
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    if: github.event.inputs.rollback != 'true'
    
    environment: 
      name: ${{ needs.pre-deployment-checks.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        kubectl config current-context

    - name: Create database backup
      run: |
        NAMESPACE="${{ needs.pre-deployment-checks.outputs.namespace }}"
        BACKUP_NAME="pre-deploy-backup-$(date +%Y%m%d-%H%M%S)"
        
        kubectl create job ${BACKUP_NAME} \
          --from=cronjob/postgres-backup \
          -n ${NAMESPACE}
        
        kubectl wait --for=condition=complete job/${BACKUP_NAME} \
          -n ${NAMESPACE} \
          --timeout=300s

    - name: Run database migrations (dry-run)
      run: |
        NAMESPACE="${{ needs.pre-deployment-checks.outputs.namespace }}"
        
        kubectl run migration-dryrun \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:${{ github.sha }} \
          --rm -i --restart=Never \
          --env="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
          --command -n ${NAMESPACE} \
          -- alembic upgrade head --sql
        
        echo "‚úÖ Migration dry-run completed successfully"

    - name: Run database migrations
      run: |
        NAMESPACE="${{ needs.pre-deployment-checks.outputs.namespace }}"
        
        kubectl run migration-apply \
          --image=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:${{ github.sha }} \
          --rm -i --restart=Never \
          --env="DATABASE_URL=${{ secrets.DATABASE_URL }}" \
          --command -n ${NAMESPACE} \
          -- alembic upgrade head
        
        echo "‚úÖ Database migration completed"

  # =============================================================================
  # KUBERNETES DEPLOYMENT
  # =============================================================================
  deploy-kubernetes:
    name: ‚ò∏Ô∏è Kubernetes Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, database-migration]
    if: always() && (needs.pre-deployment-checks.result == 'success') && (needs.database-migration.result == 'success' || github.event.inputs.rollback == 'true')

    environment: 
      name: ${{ needs.pre-deployment-checks.outputs.environment }}
      url: https://${{ needs.pre-deployment-checks.outputs.domain }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Set up Kustomize
      run: |
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
        sudo mv kustomize /usr/local/bin/

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        kubectl config current-context

    - name: Update image tags in kustomization
      run: |
        ENV="${{ needs.pre-deployment-checks.outputs.environment }}"
        OVERLAY_PATH="kubernetes/overlays/${ENV}"
        
        cd ${OVERLAY_PATH}
        
        # Update image tags to current deployment version
        kustomize edit set image \
          legal-ai-backend=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:${{ github.sha }} \
          legal-ai-frontend=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:${{ github.sha }} \
          legal-ai-nginx=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-nginx:${{ github.sha }}

    - name: Validate Kubernetes manifests
      run: |
        ENV="${{ needs.pre-deployment-checks.outputs.environment }}"
        OVERLAY_PATH="kubernetes/overlays/${ENV}"
        
        # Generate manifests
        kustomize build ${OVERLAY_PATH} > deployment-manifest.yaml
        
        # Validate manifests
        kubectl apply --dry-run=client -f deployment-manifest.yaml
        kubectl apply --dry-run=server -f deployment-manifest.yaml

    - name: Deploy to Kubernetes
      run: |
        ENV="${{ needs.pre-deployment-checks.outputs.environment }}"
        NAMESPACE="${{ needs.pre-deployment-checks.outputs.namespace }}"
        OVERLAY_PATH="kubernetes/overlays/${ENV}"
        
        echo "üöÄ Deploying to ${ENV} environment..."
        
        # Apply the deployment
        kubectl apply -k ${OVERLAY_PATH}
        
        # Wait for rollout to complete
        kubectl rollout status deployment/backend -n ${NAMESPACE} --timeout=600s
        kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=600s
        kubectl rollout status deployment/celery-worker -n ${NAMESPACE} --timeout=600s
        
        echo "‚úÖ Deployment completed successfully"

    - name: Verify deployment health
      run: |
        NAMESPACE="${{ needs.pre-deployment-checks.outputs.namespace }}"
        DOMAIN="${{ needs.pre-deployment-checks.outputs.domain }}"
        
        # Wait for services to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=backend -n ${NAMESPACE} --timeout=300s
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=frontend -n ${NAMESPACE} --timeout=300s
        
        # Health check endpoints
        for i in {1..30}; do
          if curl -f https://${DOMAIN}/health && curl -f https://${DOMAIN}/api/health; then
            echo "‚úÖ Health checks passed"
            break
          fi
          echo "‚è≥ Waiting for services to be healthy (attempt $i/30)"
          sleep 10
        done

    - name: Run smoke tests
      run: |
        DOMAIN="${{ needs.pre-deployment-checks.outputs.domain }}"
        
        # Basic functionality tests
        curl -f https://${DOMAIN}/api/v1/auth/health
        curl -f https://${DOMAIN}/api/v1/documents/health
        curl -f https://${DOMAIN}/api/v1/ai/health
        
        echo "‚úÖ Smoke tests completed successfully"

  # =============================================================================
  # POST-DEPLOYMENT TASKS
  # =============================================================================
  post-deployment:
    name: üéØ Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, deploy-kubernetes]
    if: success()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update deployment tracking
      run: |
        ENV="${{ needs.pre-deployment-checks.outputs.environment }}"
        
        # Create deployment record
        cat > deployment-record.json << EOF
        {
          "environment": "${ENV}",
          "version": "${{ github.ref_name }}",
          "commit": "${{ github.sha }}",
          "deployer": "${{ github.actor }}",
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "status": "success"
        }
        EOF

    - name: Cache deployment artifacts
      uses: actions/cache@v3
      with:
        path: |
          deployment-manifest.yaml
          deployment-record.json
        key: deployment-${{ needs.pre-deployment-checks.outputs.environment }}-${{ github.sha }}

    - name: Configure monitoring alerts
      run: |
        ENV="${{ needs.pre-deployment-checks.outputs.environment }}"
        
        # Update Prometheus alert rules for new deployment
        # This would typically involve updating alert manager configuration
        echo "üîî Configuring monitoring alerts for ${ENV}"

    - name: Warm up application caches
      run: |
        DOMAIN="${{ needs.pre-deployment-checks.outputs.domain }}"
        
        # Pre-warm application caches
        curl -X POST https://${DOMAIN}/api/v1/admin/cache/warm \
          -H "Authorization: Bearer ${{ secrets.ADMIN_API_TOKEN }}"
        
        echo "üî• Application caches warmed up"

    - name: Notify deployment success
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#legal-ai-deployments'
        text: |
          üöÄ Legal AI System deployed successfully to ${{ needs.pre-deployment-checks.outputs.environment }}
          
          **Version**: ${{ github.ref_name }}
          **Environment**: ${{ needs.pre-deployment-checks.outputs.environment }}
          **URL**: https://${{ needs.pre-deployment-checks.outputs.domain }}
          **Deployer**: ${{ github.actor }}
        fields: repo,commit,author,action,eventName,ref,workflow
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # =============================================================================
  # ROLLBACK CAPABILITY
  # =============================================================================
  rollback:
    name: ‚Ü©Ô∏è Rollback Deployment
    runs-on: ubuntu-latest
    if: github.event.inputs.rollback == 'true' || failure()
    needs: [pre-deployment-checks]

    environment: 
      name: ${{ needs.pre-deployment-checks.outputs.environment }}

    steps:
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config

    - name: Rollback deployment
      run: |
        NAMESPACE="${{ needs.pre-deployment-checks.outputs.namespace }}"
        
        echo "üîÑ Rolling back deployment in ${NAMESPACE}..."
        
        # Rollback deployments
        kubectl rollout undo deployment/backend -n ${NAMESPACE}
        kubectl rollout undo deployment/frontend -n ${NAMESPACE}
        kubectl rollout undo deployment/celery-worker -n ${NAMESPACE}
        
        # Wait for rollback to complete
        kubectl rollout status deployment/backend -n ${NAMESPACE} --timeout=300s
        kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=300s
        kubectl rollout status deployment/celery-worker -n ${NAMESPACE} --timeout=300s
        
        echo "‚úÖ Rollback completed"

    - name: Verify rollback health
      run: |
        DOMAIN="${{ needs.pre-deployment-checks.outputs.domain }}"
        
        # Health check after rollback
        for i in {1..20}; do
          if curl -f https://${DOMAIN}/health; then
            echo "‚úÖ Rollback health check passed"
            break
          fi
          echo "‚è≥ Waiting for rollback to be healthy (attempt $i/20)"
          sleep 10
        done

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#legal-ai-alerts'
        text: |
          ‚ö†Ô∏è Legal AI System deployment rolled back
          
          **Environment**: ${{ needs.pre-deployment-checks.outputs.environment }}
          **Rollback Reason**: ${{ github.event.inputs.rollback == 'true' && 'Manual rollback requested' || 'Deployment failure' }}
          **URL**: https://${{ needs.pre-deployment-checks.outputs.domain }}
        fields: repo,commit,author,action,eventName,ref,workflow
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}