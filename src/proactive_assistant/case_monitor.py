"""
Case Monitor

Comprehensive case monitoring system that tracks case status, deadlines,
document changes, and other critical events across all active cases.
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Set, Tuple
from decimal import Decimal
import asyncio
import logging
from enum import Enum
from dataclasses import dataclass, field
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload, joinedload
from sqlalchemy import select, and_, or_, func, desc
from pydantic import BaseModel, Field

from ..core.database import get_db_session
from ..trial_prep.models import Case, CaseStatus
from ..client_portal.models import Document, DocumentStatus


logger = logging.getLogger(__name__)


class AlertPriority(str, Enum):
    """Alert priority levels."""
    CRITICAL = "critical"     # Immediate attention required
    HIGH = "high"            # Urgent, should be addressed today
    MEDIUM = "medium"        # Important, address within 24-48 hours
    LOW = "low"              # Informational, can wait
    INFO = "info"            # General information


class AlertType(str, Enum):
    """Types of alerts generated by case monitoring."""
    DEADLINE_APPROACHING = "deadline_approaching"
    DEADLINE_OVERDUE = "deadline_overdue"
    DOCUMENT_FILED = "document_filed"
    HEARING_SCHEDULED = "hearing_scheduled"
    CASE_STATUS_CHANGED = "case_status_changed"
    COMPLIANCE_VIOLATION = "compliance_violation"
    BUDGET_EXCEEDED = "budget_exceeded"
    TIME_ENTRY_MISSING = "time_entry_missing"
    PAYMENT_OVERDUE = "payment_overdue"
    RESEARCH_UPDATE = "research_update"
    OPPOSING_COUNSEL_ACTIVITY = "opposing_counsel_activity"
    COURT_ORDER_RECEIVED = "court_order_received"


class MonitoringRule(BaseModel):
    """Rule for case monitoring."""
    id: str
    name: str
    description: str
    alert_type: AlertType
    priority: AlertPriority
    conditions: Dict[str, Any]
    is_active: bool = True
    created_by: int
    created_at: datetime = Field(default_factory=datetime.utcnow)


@dataclass
class CaseAlert:
    """Case monitoring alert."""
    id: str
    case_id: int
    alert_type: AlertType
    priority: AlertPriority
    title: str
    message: str
    details: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[int] = None
    resolved_at: Optional[datetime] = None
    resolved_by: Optional[int] = None
    is_active: bool = True


@dataclass
class CaseMetrics:
    """Case monitoring metrics."""
    case_id: int
    case_name: str
    status: str
    days_since_opened: int
    days_until_next_deadline: Optional[int]
    overdue_deadlines: int
    pending_documents: int
    recent_activity_count: int
    budget_utilization: float
    risk_score: float
    last_activity_date: Optional[datetime]


class CaseMonitor:
    """
    Comprehensive case monitoring system with intelligent alerting.
    """
    
    def __init__(self):
        self.monitoring_rules: List[MonitoringRule] = []
        self.active_alerts: Dict[str, CaseAlert] = {}
        self.monitoring_interval = 300  # 5 minutes
        self.is_monitoring = False
        
        # Load default monitoring rules
        self._load_default_rules()
        
    def _load_default_rules(self):
        """Load default monitoring rules."""
        default_rules = [
            MonitoringRule(
                id="deadline_7_days",
                name="7-Day Deadline Warning",
                description="Alert when deadline is 7 days away",
                alert_type=AlertType.DEADLINE_APPROACHING,
                priority=AlertPriority.HIGH,
                conditions={"days_until_deadline": 7},
                created_by=0
            ),
            MonitoringRule(
                id="deadline_1_day",
                name="1-Day Deadline Warning",
                description="Alert when deadline is 1 day away",
                alert_type=AlertType.DEADLINE_APPROACHING,
                priority=AlertPriority.CRITICAL,
                conditions={"days_until_deadline": 1},
                created_by=0
            ),
            MonitoringRule(
                id="deadline_overdue",
                name="Overdue Deadline",
                description="Alert when deadline is overdue",
                alert_type=AlertType.DEADLINE_OVERDUE,
                priority=AlertPriority.CRITICAL,
                conditions={"days_overdue": {">=": 0}},
                created_by=0
            ),
            MonitoringRule(
                id="budget_80_percent",
                name="Budget 80% Utilized",
                description="Alert when case budget reaches 80%",
                alert_type=AlertType.BUDGET_EXCEEDED,
                priority=AlertPriority.MEDIUM,
                conditions={"budget_utilization": {">=": 0.8}},
                created_by=0
            ),
            MonitoringRule(
                id="no_activity_30_days",
                name="No Activity 30 Days",
                description="Alert when case has no activity for 30 days",
                alert_type=AlertType.TIME_ENTRY_MISSING,
                priority=AlertPriority.MEDIUM,
                conditions={"days_since_activity": {">=": 30}},
                created_by=0
            )
        ]
        
        self.monitoring_rules.extend(default_rules)
        
    async def start_monitoring(self):
        """Start the case monitoring service."""
        if self.is_monitoring:
            return
            
        self.is_monitoring = True
        logger.info("Starting case monitoring service")
        
        while self.is_monitoring:
            try:
                await self._monitoring_cycle()
                await asyncio.sleep(self.monitoring_interval)
            except Exception as e:
                logger.error(f"Error in monitoring cycle: {str(e)}")
                await asyncio.sleep(60)  # Wait 1 minute before retry
                
    async def stop_monitoring(self):
        """Stop the case monitoring service."""
        self.is_monitoring = False
        logger.info("Stopping case monitoring service")
        
    async def _monitoring_cycle(self):
        """Execute one monitoring cycle."""
        async with get_db_session() as db:
            # Get all active cases
            cases = await self._get_active_cases(db)
            
            # Monitor each case
            for case in cases:
                try:
                    await self._monitor_case(case, db)
                except Exception as e:
                    logger.error(f"Error monitoring case {case.id}: {str(e)}")
                    
            # Clean up old alerts
            await self._cleanup_old_alerts()
            
        logger.debug(f"Monitoring cycle completed for {len(cases)} cases")
        
    async def _get_active_cases(self, db: AsyncSession) -> List[Case]:
        """Get all active cases that need monitoring."""
        query = select(Case).where(
            and_(
                Case.status.in_([
                    CaseStatus.ACTIVE,
                    CaseStatus.PENDING,
                    CaseStatus.IN_DISCOVERY,
                    CaseStatus.IN_TRIAL
                ]),
                Case.is_archived == False
            )
        ).options(
            selectinload(Case.deadlines),
            selectinload(Case.documents),
            selectinload(Case.time_entries)
        )
        
        result = await db.execute(query)
        return result.scalars().all()
        
    async def _monitor_case(self, case: Case, db: AsyncSession):
        """Monitor a specific case for alerts."""
        # Calculate case metrics
        metrics = await self._calculate_case_metrics(case, db)
        
        # Check each monitoring rule
        for rule in self.monitoring_rules:
            if not rule.is_active:
                continue
                
            # Check if rule conditions are met
            if await self._check_rule_conditions(rule, metrics, case, db):
                await self._generate_alert(rule, case, metrics, db)
                
    async def _calculate_case_metrics(self, case: Case, db: AsyncSession) -> CaseMetrics:
        """Calculate metrics for a case."""
        current_date = datetime.utcnow()
        
        # Days since case opened
        days_since_opened = (current_date - case.created_at).days
        
        # Next deadline
        next_deadline = None
        days_until_next_deadline = None
        
        if case.deadlines:
            upcoming_deadlines = [d for d in case.deadlines if d.due_date > current_date]
            if upcoming_deadlines:
                next_deadline = min(upcoming_deadlines, key=lambda x: x.due_date)
                days_until_next_deadline = (next_deadline.due_date - current_date).days
                
        # Overdue deadlines count
        overdue_deadlines = len([d for d in case.deadlines if d.due_date < current_date and not d.is_completed])
        
        # Pending documents count
        pending_documents = len([d for d in case.documents if d.status == DocumentStatus.DRAFT])
        
        # Recent activity (last 7 days)
        week_ago = current_date - timedelta(days=7)
        recent_activity_count = len([t for t in case.time_entries if t.created_at > week_ago])
        
        # Budget utilization (placeholder - would need budget tracking)
        budget_utilization = 0.5  # Placeholder
        
        # Risk score calculation
        risk_score = await self._calculate_risk_score(case, overdue_deadlines, days_since_opened)
        
        # Last activity date
        last_activity_date = None
        if case.time_entries:
            last_activity_date = max(case.time_entries, key=lambda x: x.created_at).created_at
            
        return CaseMetrics(
            case_id=case.id,
            case_name=case.case_name,
            status=case.status,
            days_since_opened=days_since_opened,
            days_until_next_deadline=days_until_next_deadline,
            overdue_deadlines=overdue_deadlines,
            pending_documents=pending_documents,
            recent_activity_count=recent_activity_count,
            budget_utilization=budget_utilization,
            risk_score=risk_score,
            last_activity_date=last_activity_date
        )
        
    async def _calculate_risk_score(self, case: Case, overdue_deadlines: int, days_since_opened: int) -> float:
        """Calculate risk score for a case (0.0 to 1.0)."""
        risk_factors = []
        
        # Overdue deadlines contribute heavily to risk
        if overdue_deadlines > 0:
            risk_factors.append(min(overdue_deadlines * 0.3, 0.5))
            
        # Long-running cases without resolution
        if days_since_opened > 365:
            risk_factors.append(min((days_since_opened - 365) / 365 * 0.2, 0.3))
            
        # Case complexity (placeholder - would analyze case type, value, etc.)
        complexity_score = 0.1  # Placeholder
        risk_factors.append(complexity_score)
        
        # Calculate weighted average
        if risk_factors:
            return min(sum(risk_factors) / len(risk_factors), 1.0)
        return 0.0
        
    async def _check_rule_conditions(
        self,
        rule: MonitoringRule,
        metrics: CaseMetrics,
        case: Case,
        db: AsyncSession
    ) -> bool:
        """Check if a monitoring rule's conditions are met."""
        conditions = rule.conditions
        
        # Check deadline-related conditions
        if "days_until_deadline" in conditions:
            if metrics.days_until_next_deadline is None:
                return False
            return metrics.days_until_next_deadline <= conditions["days_until_deadline"]
            
        # Check overdue conditions
        if "days_overdue" in conditions:
            overdue_condition = conditions["days_overdue"]
            if isinstance(overdue_condition, dict):
                if ">=" in overdue_condition:
                    return metrics.overdue_deadlines >= overdue_condition[">="]
            else:
                return metrics.overdue_deadlines == overdue_condition
                
        # Check budget utilization
        if "budget_utilization" in conditions:
            budget_condition = conditions["budget_utilization"]
            if isinstance(budget_condition, dict):
                if ">=" in budget_condition:
                    return metrics.budget_utilization >= budget_condition[">="]
            else:
                return metrics.budget_utilization >= budget_condition
                
        # Check activity conditions
        if "days_since_activity" in conditions:
            if metrics.last_activity_date is None:
                return True  # No activity ever
            days_since_activity = (datetime.utcnow() - metrics.last_activity_date).days
            activity_condition = conditions["days_since_activity"]
            if isinstance(activity_condition, dict):
                if ">=" in activity_condition:
                    return days_since_activity >= activity_condition[">="]
            else:
                return days_since_activity >= activity_condition
                
        return False
        
    async def _generate_alert(
        self,
        rule: MonitoringRule,
        case: Case,
        metrics: CaseMetrics,
        db: AsyncSession
    ):
        """Generate an alert based on a triggered rule."""
        # Create unique alert ID
        alert_id = f"{rule.id}_{case.id}_{int(datetime.utcnow().timestamp())}"
        
        # Check if similar alert already exists and is active
        existing_alert_key = f"{rule.id}_{case.id}"
        if existing_alert_key in self.active_alerts:
            existing_alert = self.active_alerts[existing_alert_key]
            if existing_alert.is_active and existing_alert.alert_type == rule.alert_type:
                return  # Don't create duplicate alerts
                
        # Generate alert content
        title, message = await self._generate_alert_content(rule, case, metrics)
        
        # Create alert
        alert = CaseAlert(
            id=alert_id,
            case_id=case.id,
            alert_type=rule.alert_type,
            priority=rule.priority,
            title=title,
            message=message,
            details={
                "rule_id": rule.id,
                "case_name": case.case_name,
                "metrics": {
                    "risk_score": metrics.risk_score,
                    "overdue_deadlines": metrics.overdue_deadlines,
                    "days_since_opened": metrics.days_since_opened
                }
            }
        )
        
        # Store alert
        self.active_alerts[existing_alert_key] = alert
        
        # Log alert
        logger.warning(f"Generated {rule.priority} alert for case {case.case_name}: {title}")
        
        return alert
        
    async def _generate_alert_content(
        self,
        rule: MonitoringRule,
        case: Case,
        metrics: CaseMetrics
    ) -> Tuple[str, str]:
        """Generate alert title and message."""
        case_name = case.case_name
        
        if rule.alert_type == AlertType.DEADLINE_APPROACHING:
            days = metrics.days_until_next_deadline
            title = f"Deadline Approaching: {case_name}"
            message = f"Case '{case_name}' has a deadline in {days} day{'s' if days != 1 else ''}. Please review and take necessary action."
            
        elif rule.alert_type == AlertType.DEADLINE_OVERDUE:
            count = metrics.overdue_deadlines
            title = f"Overdue Deadline{'s' if count != 1 else ''}: {case_name}"
            message = f"Case '{case_name}' has {count} overdue deadline{'s' if count != 1 else ''}. Immediate attention required."
            
        elif rule.alert_type == AlertType.BUDGET_EXCEEDED:
            utilization = metrics.budget_utilization * 100
            title = f"Budget Alert: {case_name}"
            message = f"Case '{case_name}' has utilized {utilization:.1f}% of its budget. Consider reviewing spend and adjusting as needed."
            
        elif rule.alert_type == AlertType.TIME_ENTRY_MISSING:
            days = (datetime.utcnow() - metrics.last_activity_date).days if metrics.last_activity_date else "many"
            title = f"No Recent Activity: {case_name}"
            message = f"Case '{case_name}' has had no time entries for {days} days. Please verify case status and record any activity."
            
        else:
            title = f"Alert: {case_name}"
            message = f"Case '{case_name}' requires attention based on monitoring rule '{rule.name}'."
            
        return title, message
        
    async def _cleanup_old_alerts(self):
        """Clean up old or resolved alerts."""
        cutoff_date = datetime.utcnow() - timedelta(days=30)
        
        to_remove = []
        for key, alert in self.active_alerts.items():
            # Remove old resolved alerts
            if alert.resolved_at and alert.resolved_at < cutoff_date:
                to_remove.append(key)
            # Remove very old unresolved alerts (they may no longer be relevant)
            elif alert.created_at < cutoff_date and not alert.is_active:
                to_remove.append(key)
                
        for key in to_remove:
            del self.active_alerts[key]
            
        if to_remove:
            logger.info(f"Cleaned up {len(to_remove)} old alerts")
            
    async def get_case_alerts(self, case_id: Optional[int] = None, priority: Optional[AlertPriority] = None) -> List[CaseAlert]:
        """Get active alerts, optionally filtered by case or priority."""
        alerts = []
        
        for alert in self.active_alerts.values():
            if not alert.is_active:
                continue
                
            if case_id is not None and alert.case_id != case_id:
                continue
                
            if priority is not None and alert.priority != priority:
                continue
                
            alerts.append(alert)
            
        # Sort by priority and creation date
        priority_order = {
            AlertPriority.CRITICAL: 0,
            AlertPriority.HIGH: 1,
            AlertPriority.MEDIUM: 2,
            AlertPriority.LOW: 3,
            AlertPriority.INFO: 4
        }
        
        alerts.sort(key=lambda x: (priority_order[x.priority], x.created_at), reverse=False)
        return alerts
        
    async def acknowledge_alert(self, alert_id: str, user_id: int) -> bool:
        """Acknowledge an alert."""
        for alert in self.active_alerts.values():
            if alert.id == alert_id:
                alert.acknowledged_at = datetime.utcnow()
                alert.acknowledged_by = user_id
                logger.info(f"Alert {alert_id} acknowledged by user {user_id}")
                return True
        return False
        
    async def resolve_alert(self, alert_id: str, user_id: int) -> bool:
        """Resolve an alert."""
        for alert in self.active_alerts.values():
            if alert.id == alert_id:
                alert.resolved_at = datetime.utcnow()
                alert.resolved_by = user_id
                alert.is_active = False
                logger.info(f"Alert {alert_id} resolved by user {user_id}")
                return True
        return False
        
    async def add_monitoring_rule(self, rule: MonitoringRule) -> bool:
        """Add a new monitoring rule."""
        # Check if rule with same ID exists
        for existing_rule in self.monitoring_rules:
            if existing_rule.id == rule.id:
                return False
                
        self.monitoring_rules.append(rule)
        logger.info(f"Added monitoring rule: {rule.name}")
        return True
        
    async def remove_monitoring_rule(self, rule_id: str) -> bool:
        """Remove a monitoring rule."""
        for i, rule in enumerate(self.monitoring_rules):
            if rule.id == rule_id:
                del self.monitoring_rules[i]
                logger.info(f"Removed monitoring rule: {rule_id}")
                return True
        return False
        
    async def get_monitoring_rules(self) -> List[MonitoringRule]:
        """Get all monitoring rules."""
        return self.monitoring_rules.copy()
        
    async def get_case_metrics(self, case_id: int, db: Optional[AsyncSession] = None) -> Optional[CaseMetrics]:
        """Get metrics for a specific case."""
        if not db:
            async with get_db_session() as db:
                return await self._get_case_metrics_impl(case_id, db)
        return await self._get_case_metrics_impl(case_id, db)
        
    async def _get_case_metrics_impl(self, case_id: int, db: AsyncSession) -> Optional[CaseMetrics]:
        """Implementation of case metrics retrieval."""
        query = select(Case).where(Case.id == case_id).options(
            selectinload(Case.deadlines),
            selectinload(Case.documents),
            selectinload(Case.time_entries)
        )
        
        result = await db.execute(query)
        case = result.scalar_one_or_none()
        
        if not case:
            return None
            
        return await self._calculate_case_metrics(case, db)
        
    async def get_dashboard_summary(self) -> Dict[str, Any]:
        """Get summary statistics for dashboard display."""
        active_alerts = await self.get_case_alerts()
        
        # Count alerts by priority
        alert_counts = {
            "critical": len([a for a in active_alerts if a.priority == AlertPriority.CRITICAL]),
            "high": len([a for a in active_alerts if a.priority == AlertPriority.HIGH]),
            "medium": len([a for a in active_alerts if a.priority == AlertPriority.MEDIUM]),
            "low": len([a for a in active_alerts if a.priority == AlertPriority.LOW]),
            "total": len(active_alerts)
        }
        
        # Count alerts by type
        alert_type_counts = {}
        for alert in active_alerts:
            alert_type = alert.alert_type
            alert_type_counts[alert_type] = alert_type_counts.get(alert_type, 0) + 1
            
        return {
            "monitoring_status": "active" if self.is_monitoring else "inactive",
            "total_rules": len(self.monitoring_rules),
            "active_rules": len([r for r in self.monitoring_rules if r.is_active]),
            "alert_counts": alert_counts,
            "alert_types": alert_type_counts,
            "last_cycle": datetime.utcnow()  # Would track actual last cycle time
        }